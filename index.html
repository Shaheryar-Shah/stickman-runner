<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Stickman vs Burning Trash</title>
<style>
  :root{
    --bg:#1d1d1d;
    --card:#ffffff;
    --muted:#6b7280;
    --accent:#111827;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
  /* center everything */
  .wrap{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
    box-sizing:border-box;
  }

  /* container that holds HUD + canvas */
  .container{
    width:100%;
    max-width:900px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }

  .hud{
    width:100%;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    color:var(--muted);
    font-size:14px;
    user-select:none;
  }

  #gameCanvas{
    width:100%;
    height:auto;
    background:linear-gradient(#fff,#f7f7f7);
    border-radius:10px;
    box-shadow:0 6px 20px rgba(16,24,40,0.08);
    touch-action:none;
    display:block;
  }

  .controls{
    display:flex;
    gap:8px;
    align-items:center;
  }

  .btn{
    border:1px solid #e5e7eb;
    background:#fff;
    padding:8px 12px;
    border-radius:8px;
    font-size:14px;
    cursor:pointer;
  }

  /* popup overlay with dark blur background (style 1) */
  .overlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:200;
    background:rgba(0,0,0,0.4);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }
  .overlay.show{ display:flex; }

  .dialog{
    width:min(92%,520px);
    background:var(--card);
    border-radius:12px;
    padding:18px;
    box-shadow:0 10px 30px rgba(2,6,23,0.2);
    color:#111827;
  }
  .dialog h3{ margin:0 0 8px 0; font-size:18px; }
  .dialog p{ margin:0 0 12px 0; color:var(--muted); font-size:14px; }
  .precautions{
    margin:8px 0 14px 0;
    padding-left:18px;
    color:var(--muted);
    font-size:14px;
  }
  .dialog .actions{ display:flex; justify-content:center; gap:10px; }
  .dialog .restart{
    background:#111827;color:white;padding:8px 14px;border-radius:8px;border:none;cursor:pointer;font-weight:600;
  }

  /* small note for mobile */
  .note{ font-size:13px;color:var(--muted); text-align:center; margin-top:6px; }

  @media (max-width:420px){
    .dialog{ padding:14px; }
    .hud{ font-size:13px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="container" role="application" aria-label="Stickman runner game">
    <div class="hud" aria-hidden="false">
      <div>Stickman Runner</div>
      <div style="display:flex;gap:10px;align-items:center">
        <div id="scoreDisplay">Score: 0</div>
        <div class="controls">
          <button id="restartBtn" class="btn" aria-label="Restart">Restart</button>
          <button id="installBtn" class="btn" style="display:none">Install</button>
        </div>
      </div>
    </div>

    <!-- Canvas -->
    <canvas id="gameCanvas" width="900" height="240" role="img" aria-label="Runner game canvas"></canvas>

    <div class="note">Tap inside the box to jump.</div>
  </div>
</div>

<!-- Popup overlay (dark blur background) -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="dialog" id="dialog">
    <h3>Health Precautions</h3>
    <p>Please review these precautions. (Placeholder — replace with your text.)</p>
    <ul class="precautions">
      <li>• Placeholder precaution #1 — edit me.</li>
      <li>• Placeholder precaution #2 — edit me.</li>
      <li>• Placeholder precaution #3 — edit me.</li>
    </ul>
    <div class="actions">
      <button id="dialogRestart" class="restart">Restart</button>
    </div>
  </div>
</div>

<script>
/* Service worker registration (keeps offline functionality from earlier) */
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(err => {
    // non-critical - registration might fail in local file:// or unsupported environments
    console.warn('SW registration failed', err);
  });
}

/* Canvas & scaling helpers for mobile (DPR aware) */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvasForDPR() {
  // choose logical width based on container width
  const containerWidth = canvas.clientWidth || Math.min(window.innerWidth - 40, 900);
  // logical size (we want a 3:1 ratio roughly)
  const logicalW = Math.max(320, containerWidth);
  const logicalH = Math.round(logicalW * 240 / 900); // keep height scale similar
  const dpr = Math.min(window.devicePixelRatio || 1, 3); // cap DPR for perf
  canvas.width = logicalW * dpr;
  canvas.height = logicalH * dpr;
  canvas.style.height = logicalH + 'px';
  canvas.style.width = logicalW + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing operations
}
window.addEventListener('resize', () => {
  resizeCanvasForDPR();
});
resizeCanvasForDPR();

/* Game state */
let W = canvas.width / (window.devicePixelRatio || 1);
let H = canvas.height / (window.devicePixelRatio || 1);
function updateWH(){ W = canvas.width / (window.devicePixelRatio || 1); H = canvas.height / (window.devicePixelRatio || 1); }
updateWH();

let gravity = 1.5;
let running = true;
let score = 0;
const scoreDisplay = document.getElementById('scoreDisplay');

const player = {
  x: 60,
  y: 0, // set later based on H
  w: 18,
  h: 36,
  vy: 0,
  onGround: true
};

let obstacles = [];
let spawnTimer = 0;
let baseSpeed = 14.0;
let speed = baseSpeed;

/* Responsive init */
function initSizes(){
  updateWH();
  player.y = H - 10 - player.h;
  player.x = Math.max(48, Math.round(W * 0.07));
}
initSizes();

/* Input: keyboard, mouse, touch for mobile */
function jump(){
  if (!running) return;
  if (player.onGround) {
    player.vy = -16;
    player.onGround = false;
  }
}
window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === ' ') {
    e.preventDefault();
    jump();
  }
});
canvas.addEventListener('mousedown', (e) => { e.preventDefault(); jump(); });
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive:false});

/* Restart button */
const restartBtn = document.getElementById('restartBtn');
restartBtn.addEventListener('click', resetGame);

/* Overlay controls */
const overlay = document.getElementById('overlay');
const dialogRestart = document.getElementById('dialogRestart');
dialogRestart.addEventListener('click', () => {
  hideOverlay();
  resetGame();
});

/* Game functions */
function spawnObstacle() {
  // pixel/icon-like burning trash: stacked rectangles with small flame pixels on top
  const width = 20 + Math.round(Math.random() * 32);
  const height = 18 + Math.round(Math.random() * 28);
  const x = W + 10;
  const y = H - 10 - height;
  obstacles.push({ x, y, w: width, h: height, type: 'trash' });
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function endGame() {
  running = false;
  showOverlay();
}

function showOverlay() {
  overlay.classList.add('show');
  overlay.setAttribute('aria-hidden','false');
}

function hideOverlay() {
  overlay.classList.remove('show');
  overlay.setAttribute('aria-hidden','true');
}

/* Update & draw loops */
function update() {
  if (!running) return;
  // physics
  player.vy += gravity;
  player.y += player.vy;
  if (player.y + player.h >= H - 10) {
    player.y = H - 10 - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  // spawn logic (more frequent at higher scores)
  spawnTimer--;
  if (spawnTimer <= 0) {
    spawnTimer = Math.max(36, 60 + Math.round(Math.random() * 80) - Math.round(score / 100));
    spawnObstacle();
  }

  // update obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    o.x -= speed;
    if (o.x + o.w < 0) obstacles.splice(i,1);
    // collision detection with small padding
    const playerBox = { x: player.x + 2, y: player.y, w: player.w - 4, h: player.h };
    if (rectsOverlap(playerBox, o)) {
      endGame();
      return;
    }
  }

  // scoring & difficulty
  score += 1;
  if (score % 300 === 0) speed += 0.25;
  scoreDisplay.textContent = 'Score: ' + Math.floor(score / 10);
}

function drawTrash(o) {
  const px = o.x, py = o.y, pw = o.w * 0.8, ph = o.h * 0.8; // slightly smaller trash

  // Draw multiple trash layers
  ctx.fillStyle = '#4a3c2b'; // dark brown
  ctx.fillRect(px, py + ph*0.6, pw, ph*0.4); // base layer
  ctx.fillRect(px + 2, py + ph*0.35, pw*0.75, ph*0.25); // mid layer
  ctx.fillRect(px + 4, py, pw*0.5, ph*0.25); // top layer

  // Draw flames with bigger flicker
  const flameColors = ['#ff9f1c','#ff3f00','#ffd27f'];
  for(let i=0;i<3;i++){
    const fx = px + pw*0.15 + Math.random()*pw*0.7;
    const fy = py - Math.random()*12; // taller flames
    ctx.fillStyle = flameColors[i];
    ctx.fillRect(fx, fy, 6, 12); // wider and taller flames
  }

  // Optional: small spark highlights
  for(let i=0;i<2;i++){
    const sx = px + Math.random()*pw;
    const sy = py - Math.random()*6;
    ctx.fillStyle = '#fff3b0';
    ctx.fillRect(sx, sy, 2, 2);
  }
}

function drawStickman(){
  const px = player.x;
  const py = player.y;
  const w = player.w;
  const h = player.h;

  ctx.lineWidth = 2;
  ctx.strokeStyle = '#111827';
  ctx.fillStyle = '#111827';

  // head (small circle)
  const headRadius = 5;
  ctx.beginPath();
  ctx.arc(px + w/2, py + headRadius + 2, headRadius, 0, Math.PI*2);
  ctx.fill();

  // body line
  ctx.beginPath();
  ctx.moveTo(px + w/2, py + headRadius*2 + 4);
  ctx.lineTo(px + w/2, py + h - 6);
  ctx.stroke();

  // arms (simple)
  ctx.beginPath();
  ctx.moveTo(px + w/2 - 8, py + headRadius*2 + 8);
  ctx.lineTo(px + w/2 + 8, py + headRadius*2 + 12);
  ctx.stroke();

  // legs (one leg slightly forward if jumping)
  ctx.beginPath();
  const legY = py + h - 6;
  ctx.moveTo(px + w/2, legY);
  // left leg
  ctx.lineTo(px + w/2 - 8, legY + 10);
  // right leg
  ctx.moveTo(px + w/2, legY);
  ctx.lineTo(px + w/2 + 10, legY + (player.onGround ? 10 : 4));
  ctx.stroke();
}

/* rendering */
function draw() {
  // clear
  ctx.clearRect(0,0,W,H);
  // ground
  ctx.fillStyle = '#e6e6e6';
  ctx.fillRect(0, H-10, W, 10);

  // horizon line / faint ground texture
  ctx.fillStyle = '#f8f8f8';
  for (let gx=0; gx<W; gx+=30) {
    ctx.fillRect(gx, H-10, 14, 2);
  }

  // draw obstacles
  obstacles.forEach(o => {
    if (o.type === 'trash') drawTrash(o);
    else {
      ctx.fillStyle = '#2b2b2b';
      ctx.fillRect(o.x, o.y, o.w, o.h);
    }
  });

  // draw player (stickman)
  drawStickman();
}

/* Main loop */
let rafId;
function loop(){
  update();
  draw();
  if (running) rafId = requestAnimationFrame(loop);
}

/* Reset game */
function resetGame(){
  // re-size to ensure proper layout on restart if device rotated
  resizeCanvasForDPR();
  initSizes();
  obstacles = [];
  score = 0;
  speed = baseSpeed;
  spawnTimer = 50;
  player.vy = 0;
  player.onGround = true;
  running = true;
  hideOverlay();
  if (rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(loop);
}

/* initial start */
resetGame();

/* keep dims accurate when CSS resizes */
const resizeObserver = new ResizeObserver(() => {
  resizeCanvasForDPR();
  initSizes();
});
resizeObserver.observe(canvas);

/* beforeinstallprompt for installable experience */
let deferredPrompt;
const installBtn = document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = 'inline-block';
});
installBtn.addEventListener('click', async () => {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    const choice = await deferredPrompt.userChoice;
    deferredPrompt = null;
    installBtn.style.display = 'none';
  } else {
    alert('Visit this page once while online to cache it for offline play.');
  }
});

/* Pause interactions while overlay is visible */
overlay.addEventListener('click', (e) => {
  // clicking outside the dialog will not close overlay (explicit restart only)
  e.stopPropagation();
});
</script>
</body>
</html>
